GRAMMAR = ->
  o "__INIT__ LINES __EXIT__"
  i __INIT__:                     "_BLANKLINE*",   -> # init code
  i __EXIT__:                     "_BLANKLINE* _", -> # exit code
  i LINES:                        "LINE*_NEWLINE", Block
  i LINE: ->
    o HEREDOC:                    "_ '###' !'#' (!'###' .)* '###'", (it) -> Heredoc it.join ''
    o POSTIF:                     "block:(POSTIF|POSTFOR) &:(POSTIF_IF|POSTIF_UNLESS)"
    i POSTIF_IF:                  "_IF cond:EXPR", If
    i POSTIF_UNLESS:              "_UNLESS cond:EXPR", ({cond}) -> If cond:Operation(op:'not', right:cond)
    o POSTFOR: ->
      o                           "block:STMT _FOR own:_OWN? keys:SYMBOL*_COMMA{1,2} type:(_IN|_OF) obj:EXPR (_WHEN cond:EXPR)?", For
      o STMT: ->
        o                         "type:(_RETURN|_THROW) expr:EXPR? | type:_BREAK", Statement
        o EXPR: ->
          o FUNC:                 "params:PARAMS? _ type:('->'|'=>') block:BLOCK?", Func
          i PARAMS:               "_ '(' (&:PARAM default:(_ '=' EXPR)?)*_COMMA _ ')'"
          i PARAM:                "&:SYMBOL splat:'...'?
                                  |&:PROPERTY splat:'...'?
                                  |OBJ_EXPL
                                  |ARRAY"

          o RIGHT_RECURSIVE: ->
            o INVOC_IMPL:         "func:(ASSIGNABLE|_TYPEOF) params:(&:EXPR splat:'...'?)+_COMMA", Invocation
            o OBJ_IMPL:           "_INDENT? OBJ_IMPL_ITEM+(_COMMA | _NEWLINE)
                                   | OBJ_IMPL_ITEM+_COMMA", Obj
            i OBJ_IMPL_ITEM:      "key:(WORD|STRING) _ ':' value:EXPR", Item
            o ASSIGN:             "target:ASSIGNABLE _ type:('='|'+='|'-='|'*='|'/='|'?='|'||=') value:BLOCKEXPR", Assign

          o COMPLEX: ->
            o IF:                 "_IF cond:EXPR block:BLOCK else:(_NEWLINE? _ELSE BLOCK)?", If
            o FOR:                "_FOR own:_OWN? keys:SYMBOL*_COMMA{1,2} type:(_IN|_OF) obj:EXPR (_WHEN cond:EXPR)? block:BLOCK", For
            o LOOP:               "_LOOP block:BLOCK", While
            o WHILE:              "_WHILE cond:EXPR block:BLOCK", While
            o SWITCH:             "_SWITCH obj:EXPR _INDENT cases:CASE*_NEWLINE default:DEFAULT?", Switch
            i CASE:               "_WHEN matches:EXPR+_COMMA block:BLOCK", Case
            i DEFAULT:            "_NEWLINE _ELSE BLOCK"
            o TRY:                "_TRY block:BLOCK
                                   (_NEWLINE? doCatch:_CATCH catchVar:EXPR? catchBlock:BLOCK?)?
                                   (_NEWLINE? _FINALLY finally:BLOCK)?", Try

          o OP_OPTIMIZATION:      "OP40 _ !(OP00_OP|OP10_OP|OP20_OP|OP30_OP)"
          o OP00: ->
            o                     "left:(OP00|OP10) _ op:(OP00_OP: '=='|'!='|'<='|'<'|'>='|'>'|_IS|_ISNT) _SOFTLINE? right:OP10", Operation
            o OP10: ->
              o                   "left:(OP10|OP20) _  @:(OP10_OP: not:_NOT? op:(_IN|_INSTANCEOF))        _SOFTLINE? right:OP20", Operation
              o OP20: ->
                o                 "left:(OP20|OP30) _ op:(OP20_OP: '+'|'-'|'?'|_OR)                       _SOFTLINE? right:OP30", Operation
                o OP30: ->
                  o               "left:(OP30|OP40) _ op:(OP30_OP: '*'|'/'|'%'|'&&'|'&'|_AND)             _SOFTLINE? right:OP40", Operation
                  o OP40: ->
                    o             "                 _ op:(OP40_OP: _NOT|'!'|'~')                                     right:OP50", Operation
                    o OP50: ->
                      o           "left:OPATOM        op:(OP50_OP: '--'|'++')                                                  ", Operation
                      o           "                 _ op:(OP50_OP)                                                 right:OPATOM", Operation
                      o OPATOM:   "FUNC | RIGHT_RECURSIVE | COMPLEX | ASSIGNABLE"

  i ASSIGNABLE: ->
    # left recursive
    o SLICE:        "obj:ASSIGNABLE !__ range:RANGE", Slice
    o INDEX0:       "obj:ASSIGNABLE type:'['  attr:EXPR _ ']'", Index
    o INDEX1:       "obj:ASSIGNABLE type:'.'  attr:WORD", Index
    o PROTO:        "obj:ASSIGNABLE type:'::' attr:WORD?", Index
    o INVOC_EXPL:   "func:(ASSIGNABLE|_TYPEOF) '(' ___ params:(&:EXPR splat:'...'?)*_COMMA ___ ')'", Invocation
    o SOAK:         "ASSIGNABLE '?'", Soak
    # rest
    o RANGE:        "_ '[' start:EXPR? _ type:('...'|'..') end:EXPR? _ ']' by:(_BY EXPR)?", Range
    o ARRAY:        "_ '[' ___ (&:EXPR splat:'...'?)*(_COMMA|_SOFTLINE) ___ ']'", Arr
    o OBJ_EXPL:     "_ '{' ___ OBJ_EXPL_ITEM*_COMMA ___ '}'", Obj
    i OBJ_EXPL_ITEM: "key:(PROPERTY|WORD|STRING) value:(_ ':' EXPR)?", Item
    o PARENT:       "_ '(' POSTFOR _ ')'"
    o PROPERTY:     "_ '@' (WORD|STRING)", (attr) -> Index obj:This(), attr:attr
    o THIS:         "_ '@'", This
    o REGEX:        "_ _FSLASH &:(!_FSLASH (ESC2 | .))* _FSLASH <words:1> flags:/[a-zA-Z]*/", Str
    o STRING: ->
      o             "_ _QUOTE  (!_QUOTE  (ESCSTR | .))* _QUOTE",  Str
      o             "_ _TQUOTE (!_TQUOTE (ESCSTR | INTERP | .))* _TQUOTE", Str
      o             "_ _DQUOTE (!_DQUOTE (ESCSTR | INTERP | .))* _DQUOTE", Str
      i ESCSTR:     "_SLASH .", (it) -> {n:'\n', t:'\t', r:'\r'}[it] or it
      i INTERP:     "'\#{' _BLANKLINE* _RESETINDENT EXPR ___ '}'"
    o BOOLEAN:      "_TRUE | _FALSE", (it) -> it is 'true'
    o NUMBER:       "_ <words:1> /-?[0-9]+(\\.[0-9]+)?/", Number
    o SYMBOL:       "_ !_KEYWORD WORD"

  ### BLOCKS ###
  i BLOCK:          "_INDENT LINE*_NEWLINE
                   | _THEN?  LINE+(_ ';')", Block
  i BLOCKEXPR:      "_INDENT? EXPR"
  i _INDENT:        "_BLANKLINE+ &:_", checkIndent
  i _NEWLINE: ->
    o               "_BLANKLINE+ &:_", checkNewline
    o               "_ ';'"
    skipCache:      yes
  i _SOFTLINE:      "_BLANKLINE+ &:_", checkSoftline
  i _RESETINDENT:   "_BLANKLINE* &:_", resetIndent

  ### TOKENS ###
  i _KEYWORD:       tokens 'if', 'unless', 'else', 'for', 'own', 'in', 'of', 'loop', 'while', 'break', 'switch',
                      'when', 'return', 'throw', 'then', 'is', 'isnt', 'true', 'false', 'by',
                      'not', 'and', 'or', 'instanceof', 'typeof', 'try', 'catch', 'finally'
  i _COMMA:         "___ ',' ___"
  i _QUOTE:         "'\\''"
  i _DQUOTE:        "'\"'"
  i _TQUOTE:        "'\"\"\"'"
  i _FSLASH:        "'/'"
  i _SLASH:         "'\\\\'"
  i '.':            "<chars:1> /[\\s\\S]/",       skipLog:yes
  i ESC1:           "_SLASH .",                   skipLog:yes
  i ESC2:           "_SLASH .",                   skipLog:yes, ((chr) -> '\\'+chr)
  i WORD:           "_ <words:1> /[a-zA-Z\\$_][a-zA-Z\\$_0-9]*/", Word

  ### WHITESPACES ###
  i _:              "<words:1> /[ ]*/",           skipLog:yes
  i __:             "<words:1> /[ ]+/",           skipLog:yes
  i _TERM:          "_ ('\r\n'|'\n')",            skipLog:yes
  i _COMMENT:       "_ !HEREDOC '#' (!_TERM .)*", skipLog:yes
  i _BLANKLINE:     "_ _COMMENT? _TERM",          skipLog:yes
  i ___:            "_BLANKLINE* _",              skipLog:yes

{Grammar} = require './joeson'
Grammar.fromFile './joescript_grammar.joe'
