GRAMMAR = ->
  o                                 "_BLANKLINE* LINES ___", __init__
  i LINES:                          "LINE*_NEWLINE", Block
  i LINE: ->
    o HEREDOC:                      "_ '###' !'#' (!'###' .)* '###'", (it) -> Heredoc it.join ''
    o LINEEXPR: ->
      # left recursive
      o POSTIF:                     "block:LINEEXPR _IF cond:EXPR", If
      o POSTUNLESS:                 "block:LINEEXPR _UNLESS cond:EXPR", Unless
      o POSTFOR:                    "block:LINEEXPR _FOR own:_OWN? keys:SYMBOL*_COMMA{1,2} type:(_IN|_OF) obj:EXPR (_WHEN cond:EXPR)?", For
      # rest
      o STMT:                       "type:(_RETURN|_THROW|_BREAK|_CONTINUE) expr:EXPR?", Statement
      o EXPR: ->
        o FUNC:                     "params:PARAMS? _ type:('->'|'=>') block:BLOCK?", Func
        i PARAMS:                   "_ '(' (&:PARAM default:(_ '=' LINEEXPR)?)*_COMMA _ ')'"
        i PARAM:                    "&:SYMBOL splat:'...'?
                                    |&:PROPERTY splat:'...'?
                                    |OBJ_EXPL
                                    |ARR_EXPL"
        o RIGHT_RECURSIVE: ->
          o INVOC_IMPL:             "func:ASSIGNABLE (? __|OBJ_IMPL_INDENTED) params:(&:EXPR splat:'...'?)+(_COMMA | _COMMA_NEWLINE)", Invocation
          i OBJ_IMPL_INDENTED:      "_INDENT OBJ_IMPL_ITEM+(_COMMA|_NEWLINE)", Obj
          o OBJ_IMPL:               "_INDENT? OBJ_IMPL_ITEM+(_COMMA|_NEWLINE)", Obj
          i OBJ_IMPL_ITEM:          "key:(WORD|STRING) _ ':' value:EXPR", Item
          o ASSIGN:                 "target:ASSIGNABLE _ type:('='|'+='|'-='|'*='|'/='|'?='|'||=') value:BLOCKEXPR", Assign
        o COMPLEX: ->
          o IF:                     "_IF cond:EXPR block:BLOCK ((_NEWLINE | _INDENT)? _ELSE elseBlock:BLOCK)?", If
          o UNLESS:                 "_UNLESS cond:EXPR block:BLOCK ((_NEWLINE | _INDENT)? _ELSE elseBlock:BLOCK)?", Unless
          o FOR:                    "_FOR own:_OWN? keys:SYMBOL*_COMMA{1,2} type:(_IN|_OF) obj:EXPR (_WHEN cond:EXPR)? block:BLOCK", For
          o LOOP:                   "_LOOP block:BLOCK", While
          o WHILE:                  "_WHILE cond:EXPR block:BLOCK", While
          o SWITCH:                 "_SWITCH obj:EXPR _INDENT cases:CASE*_NEWLINE default:DEFAULT?", Switch
          i CASE:                   "_WHEN matches:EXPR+_COMMA block:BLOCK", Case
          i DEFAULT:                "_NEWLINE _ELSE BLOCK"
          o TRY:                    "_TRY block:BLOCK
                                     (_NEWLINE? doCatch:_CATCH catchVar:EXPR? catchBlock:BLOCK?)?
                                     (_NEWLINE? _FINALLY finally:BLOCK)?", Try
        o OP_OPTIMIZATION:          "OP40 _ !(OP00_OP|OP05_OP|OP10_OP|OP20_OP|OP30_OP)"
        o OP00: ->
          i OP00_OP:                " '&&' | '||' | '&' | '|' | '^' | _AND | _OR "
          o                         "left:(OP00|OP05) _ op:OP00_OP _SOFTLINE? right:OP05", Operation
          o OP05: ->
            i OP05_OP:              " '==' | '!=' | '<=' | '<' | '>=' | '>' | _IS | _ISNT "
            o                       "left:(OP05|OP10) _ op:OP05_OP _SOFTLINE? right:OP10", Operation
            o OP10: ->
              i OP10_OP:            " '+' | '-' "
              o                     "left:(OP10|OP20) _ op:OP10_OP _SOFTLINE? right:OP20", Operation
              o OP20: ->
                i OP20_OP:          " '*' | '/' | '%' "
                o                   "left:(OP20|OP30) _ op:OP20_OP _SOFTLINE? right:OP30", Operation
                o OP30: ->
                  i OP30_OP:        "not:_NOT? op:(_IN|_INSTANCEOF)"
                  o                 "left:(OP30|OP40) _  @:OP30_OP _SOFTLINE? right:OP40", Operation
                  o OP40: ->
                    i OP40_OP:      " _NOT | '!' | '~' "
                    o               "_ op:OP40_OP right:OP45", Operation
                    o OP45: ->
                      i OP45_OP:    " '?' "
                      o             "left:(OP45|OP50) _ op:OP45_OP _SOFTLINE? right:OP50", Operation
                      o OP50: ->
                        i OP50_OP:  " '--' | '++' "
                        o           "left:OPATOM op:OP50_OP", Operation
                        o           "_ op:OP50_OP right:OPATOM", Operation
                        o OPATOM:   "FUNC | RIGHT_RECURSIVE | COMPLEX | ASSIGNABLE"
  i ASSIGNABLE: ->
    # left recursive
    o SLICE:        "obj:ASSIGNABLE !__ range:RANGE", Slice
    o INDEX0:       "obj:ASSIGNABLE type:'['  attr:LINEEXPR _ ']'", Index
    o INDEX1:       "obj:ASSIGNABLE type:'.'  attr:WORD", Index
    o PROTO:        "obj:ASSIGNABLE type:'::' attr:WORD?", Index
    o INVOC_EXPL:   "func:ASSIGNABLE '(' ___ params:(&:LINEEXPR splat:'...'?)*(_COMMA|_SOFTLINE) ___ ')'", Invocation
    o SOAK:         "ASSIGNABLE '?'", Soak
    # rest
    o TYPEOF: ->
      o             "func:_TYPEOF '(' ___ params:LINEEXPR{1,1} ___ ')'", Invocation
      o             "func:_TYPEOF __ params:LINEEXPR{1,1}", Invocation
    o RANGE:        "_ '[' start:LINEEXPR? _ type:('...'|'..') end:LINEEXPR? _ ']' by:(_BY EXPR)?", Range
    o ARR_EXPL:     "_ '[' _SOFTLINE? (&:LINEEXPR splat:'...'?)*(_COMMA|_SOFTLINE) ___ ']'", Arr
    o OBJ_EXPL:     "_ '{' _SOFTLINE? OBJ_EXPL_ITEM*(_COMMA|_SOFTLINE) ___ '}'", Obj
    i OBJ_EXPL_ITEM: "key:(PROPERTY|WORD|STRING) value:(_ ':' LINEEXPR)?", Item
    o PAREN:        "_ '(' ___ LINEEXPR ___ ')'"
    o PROPERTY:     "_ '@' (WORD|STRING)", (attr) -> Index obj:This(), attr:attr
    o THIS:         "_ '@'", This
    o REGEX:        "_ _FSLASH &:(!_FSLASH (ESC2 | .))* _FSLASH <words:1> flags:/[a-zA-Z]*/", Str
    o STRING: ->
      o             "_ _QUOTE  (!_QUOTE  (ESCSTR | .))* _QUOTE",  Str
      o             "_ _TQUOTE (!_TQUOTE (ESCSTR | INTERP | .))* _TQUOTE", Str
      o             "_ _DQUOTE (!_DQUOTE (ESCSTR | INTERP | .))* _DQUOTE", Str
      i ESCSTR:     "_SLASH .", (it) -> {n:'\n', t:'\t', r:'\r'}[it] or it
      i INTERP:     "'\#{' _BLANKLINE* _RESETINDENT LINEEXPR ___ '}'"
    o BOOLEAN:      "_TRUE | _FALSE", (it) -> it is 'true'
    o NUMBER:       "_ <words:1> /-?[0-9]+(\\.[0-9]+)?/", Number
    o SYMBOL:       "_ !_KEYWORD WORD"

  # BLOCKS:
  i BLOCK: ->
    o               "_INDENT LINE*_NEWLINE", Block
    o               "_THEN?  LINE+(_ ';')", Block
  i BLOCKEXPR:      "_INDENT? EXPR"
  i _INDENT:        "_BLANKLINE+ &:_", checkIndent, skipCache:yes
  i _RESETINDENT:   "_BLANKLINE* &:_", resetIndent, skipCache:yes
  i _NEWLINE: ->
    o               "_BLANKLINE+ &:_", checkNewline, skipCache:yes
    o               "_ ';'"
    skipCache:yes
  i _SOFTLINE:      "_BLANKLINE+ &:_", checkSoftline, skipCache:yes
  i _COMMA:         "beforeBlanks:_BLANKLINE* beforeWS:_ ','
                      afterBlanks:_BLANKLINE*  afterWS:_", checkComma, skipCache:yes
  i _COMMA_NEWLINE: "_BLANKLINE+ &:_", checkCommaNewline, skipCache:yes

  # TOKENS:
  i WORD:           "_ <words:1> /[a-zA-Z\\$_][a-zA-Z\\$_0-9]*/", Word
  i _KEYWORD:       tokens('if', 'unless', 'else', 'for', 'own', 'in', 'of',
                      'loop', 'while', 'break', 'continue',
                      'switch', 'when', 'return', 'throw', 'then', 'is', 'isnt', 'true', 'false', 'by',
                      'not', 'and', 'or', 'instanceof', 'typeof', 'try', 'catch', 'finally')
  i _QUOTE:         "'\\''"
  i _DQUOTE:        "'\"'"
  i _TQUOTE:        "'\"\"\"'"
  i _FSLASH:        "'/'"
  i _SLASH:         "'\\\\'"
  i '.':            "<chars:1> /[\\s\\S]/",            skipLog:yes
  i ESC1:           "_SLASH .",                        skipLog:yes
  i ESC2:           "_SLASH .", ((chr) -> '\\'+chr),   skipLog:yes

  # WHITESPACES:
  i _:              "<words:1> /[ ]*/",                skipLog:yes
  i __:             "<words:1> /[ ]+/",                skipLog:yes
  i _TERM:          "_ ('\r\n'|'\n')",                 skipLog:yes
  i _COMMENT:       "_ !HEREDOC '#' (!_TERM .)*",      skipLog:yes
  i _BLANKLINE:     "_ _COMMENT? _TERM",               skipLog:yes
  i ___:            "_BLANKLINE* _",                   skipLog:yes


{Grammar} = require './joeson'
g = Grammar.fromFile './joescript_grammar.joe'
console.log ''+g.compile()
